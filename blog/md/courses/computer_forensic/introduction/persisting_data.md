# PERSISTING DATA

### **Evidence preservation approaches**

The first task at a computer crime scene is to preserve evidence. The data you collect there may be all you have in solving a criminal case or policy violation, so you should be extremely careful to capture everything possible. While in a hurry to collect evidence, it's entirely possible to make significant mistakes, like accidentally adding, deleting, or modifying data. The consequences are grave, because the court may not accept the compromised digital evidence you submit. This possibility is why we have to do our best to keep our evidence as pristine as possible, which is the primary goal of data preservation in digital forensics. Luckily, we have well-established and concrete ways to preserve data. The first option is using write-blockers when copying data from a source, such as a hard drive in your computer, a USB drive, or an external data storage device. As their name suggests, write-blockers prevent writing to an evidence drive. After deploying your favorite write-blocker, but before making a copy of a data storage medium, the best practice is to get a hash value. This process generates a unique string, represent a specific data set like a partition. You can produce another hash value once you get a copy of the partition. If the hash values don't match, the source and its copy are not identical. Mounting and unmounting drives are also relevant to data preservation, especially in Linux and Unix operating systems. Mounting is a mechanism an operating system or OS uses to make a drive or partition visible. If the OS doesn't recognize a data source, it cannot do anything to it, which is why we always want to begin with a drive unmounted before starting our forensic work. With data preservation techniques, such as write-blockers, hashing, and unmounting, there is much less chance for mishaps. They also ensure that your evidence collection process is sound and valid.

### **Understanding the role of write blockers**

Computer forensics rule number one is not damaging your evidence. Here, the evidence refers to your evidence drive. The risk you're constantly running into is your operating system writing to your evidence drive. One of the countermeasures to keep this from happening is using a writeblocker. There are primarily two different types of writeblockers. The first type is hardware right blockers. This picture shows what a hardware writeblocker looks like. Usually these devices sit between an evidence drive and a forensic workstation. The second type is a software writeblocker, and sometimes it's built into a computer forensic suite like in Case or FTK. You could also accomplish the same writeblocking effect by changing the configuration of your operating system. In addition to writeblocking, there are other factors to consider to protect the viability of your evidence. Physical security or chain of custody is one of them. By taking care of it, you know who had access to the physical evidence drive when and why. You can record all this information in a chain of custody form. Let's say making an image of an evidence drive using a writeblocker went flawlessly. If your evidence drive still turns out to be compromised, now you know it happened through unauthorized physical access.

### **Using a software write blocker**

Let's enable write blocking on Windows 10 so that the operating system is not able to write to a USB drive. To enable write blocking, we have to run a program called R-E-G-E-D-I-T, or Registry Editor. To run this program, press the Windows key and R key together. Type regedit, as I did here. Click on OK. Now you see the Registry Editor window. Choose HKEY\_LOCAL\_MACHINE, choose SYSTEM, and then choose CurrentControlSet and then select Control. Do a right-click and choose New, and then select Key. Changing a registry setting on your computer could be dangerous. If you decide to follow what I'm doing, do it at your own risk, but be very careful. Now, type StorageDevicePolicies in the box and then do a right-click on the folder. Choose New and then choose DWORD 32-bit Value. Even if you're running a 64-bit OS, make sure that you still choose 32-bit option. Now type WriteProtect. Do another right-click, choose Modify and change the value data to 1\. What this does is enabling the write blocking feature. A lot of times in computer science, 1 means true while 0 means false. In this case, the write blocking option is now set to true, and therefore, you're enabling write blocking. Now click OK. Now let's restart the machine. The machine has been rebooted. Let's see our write blocking in action. We'll create a new folder on the desktop. Let's name it Test. Double-click on the folder, click on This PC, and you see the USB Drive here. We'll try to drag and drop the new folder onto the USB drive. And you will get this message saying, "The disk is write-protected." Therefore, the write blocking option is now enabled and working very well. This software-based write-blocking option is the cheapest way of accomplishing write blocking. You don't need any special software. If your operating system doesn't support this type of write blocking option, you'll need to have a special software program to enable write blocking For more serious forensics tasks, you'll need hardware write blockers.

### **Using hardware write blockers**

Selecting transcript lines in this section will navigate to timestamp in the video.
Hardware write blockers come in many different forms. Let's look at some popular solutions. The most basic solution is to connect an evidence drive through a USB interface. Here you rely on software for write blocking. The hardware simply provides a physical interface between your evidence drive and computer forensics workstation. A slightly more advanced solution is a hard drive docking station. The most significant advantage here is the cleaner form factor. There are fewer cables to mess with. However, the docking station approach also requires software to block writing. Professionals deserve more sophisticated solutions. The primary goal is to block writing and avoid accidents to comply with legal standards and requirements. Let's say that you're conducting an investigation and in the middle of it, something goes wrong with your hardware write blocker, and that's the last thing you want. These professional-grade hardware write blockers are more expensive, but provide ironclad operations. There are some well-known manufacturers of hardware write blockers such as WiebeTech by CRU. This company is a manufacturer of many other types of computer forensics equipment too. One of the main features of WiebeTech write blockers is more interface options. This particular product featured here provides USB 3.2 Type-C. It also comes with more convenient features like switches and digital displays. The most advanced hardware write blocking option is hard drive duplicators. They're fast and primarily plug and play. All you have to do is plug in your hard drive and then the duplicator will take care of the rest. Therefore, it provides an automated solution. When buying a hardware write blocker, base your purchasing decision on the purpose and the nature of your investigation. You rarely need the most expensive equipment out there. Here the key is that you're making an informed decision.

### **Understanding hashing**

Hashing plays a vital role in computer forensics. It ensures that a data copy you make remains identical to its source. Hashing refers to the process of transforming an input, which is usually a file into an output, which is a unique string associated with that file. There are some significant characteristics you should know about hashing. First, any slight changes you make in a file will get amplified in considerable changes in its hash value. This behavior makes it very easy to detect changes made to a file by accident or on purpose. Hashing ensures data integrity, meaning no intended changes are made in the data. In the context of computer forensics, this means the evidence drive remains the same during your investigation. That is, a forensic image or copy of the evidence drive stays the same. Therefore, hashing is an essential part of your computer forensics investigation. Any non-trivial computer forensics tools should be kept to produce hash values.

### **Hashing algorithms**

There are various implementations of hash algorithms. One of the well-known hash algorithms is MD5, which has been widely used in digital forensics. However, it's proven to be vulnerable. Another algorithm called the secure hash algorithm, or SHA, is a more secure version of MD5. There are many different variations of SHA. Collision is a non vulnerability in hash algorithms. It occurs when two different files produce the same hash value when put through the same algorithm. As you can see in this diagram, file one and file two are different, but when they go through the same hash algorithm, sometimes it's possible to end up with the same hash value. This problem rarely happens, but theoretically speaking, it could occur. Collisions have been found in both MD5 and SHA. A way to make a hash algorithm less vulnerable is to increase the size of its output. The bigger the hash value, the less the possibility of a collision. That is, a larger hash value means more secure hashing.

### **Case Study: Hashing in FTK Imager**

Many of the computer forensics tools available today come equipped with built-in hash functions. The primary purpose of these built-in hash features is the verification and validation of your data you're working on in your computer forensics investigation. For example, there's a tool called FTK Imager and it comes with both MD5 and SHA hash algorithms. An alternative to using these built-in hash options is manually computing hash values. As we saw in another lesson, you can use a Linux hash algorithm implementation such as MD5 Sum. In this lesson, let's try the hash features of the FTK Imager. First choose file, click create disk image. We'll go for the default choice, physical drive, and click on next. From this list, choose your drive. I'm choosing the smallest drive just to make it quick. Click on finish. Now it's asking for image destinations. Let's click on add. Now we need to select the destination image type. We'll be using the raw image type, which is DD. Click on next. I chose DD because it's a universal imaging format used by many other tools. Here I'll use my case number as 001\. Evidence number also 001\. Unique description is going to be test. Examiner 001, and I'll type test for the notes field. Click on next. Now I'll choose the image destination folder. Click on browse, I'm going to choose desktop. This way we can see the image being created on our desktop. The image file name I'll be using is my drive, my drive. Here you can break your image file into multiple files. It's called fragmentation in this case. I don't want to do this. That's why I type zero here. Click on finish, not bad. There's an option of verifying images after they're created. By selecting this option at the end of the imaging process, you'll have the hash values of the image files. Make sure you choose that option and click on start. As you can see, once the imaging process is over, the FTK Imager tool will display the MD5 hash value of the image and also the SHA-1 hash value of the image. This demonstrates the built-in hash functions of the FTK Imager tool. Note that the FTK Imager tool computed the hash values before imaging, and then it gets the hash values again after imaging is done, and it shows that the hash values match.

### **Understanding mounting**

Mounting is a concept related to partitioning. We already learned about partitioning in another lesson. Mounting is the process of making a partition visible to an operating system, or OS, and eventually to an end user, especially on a Linux operating system. Unmounting is the opposite. Connecting the drive and making it available to an OS can be dangerous because your OS can write to it. Another concept related to mounting is that of a mount point. It's simply a directory where a partition is made visible after mounting is done. Let's do a quick demo of mounting here. I already have my USB drive plugged into my computer. As soon as you plug in your USB drive, you'll see an icon like this. What this means is that your OS picked up your USB drive. This is probably the last thing you want in your computer forensics workstation because your OS could have written to your USB drive, which could be your evidence drive. The mounting happened because the operating system you're using is not a forensic copy. In a forensic copy, the OS won't automatically mount a USB drive like this. Therefore, we'll start by unmounting our USB drive. To unmount a USB drive, type umount, and then the name of the partition. But in this case, we don't know what the name of the partition is for the USB drive. To know the partition name, we need another command, which is fdisk. Type sudo fdisk \-l. You cannot run your fdisk command directly because it requires administrator privilege to run, so that's why I type sudo in front. This is equivalent to running a program as an administrator on a Windows operating system. Now I'm ready to press enter. Press enter. It's asking for the password and press enter. The default password is kali. That's what I typed. Here we see all the storage devices connected to our computer and partitions on them. The storage device we're interested in is our USB drive. In this case, the USB drive and its partition are showing up as /dev/sdb1. And this is exactly the name to use to unmount the USB drive. I know the USB drive is SDB because SDA is the first disk drive letter referring to a hard drive, and I also know there's only one hard drive attached to my computer. The next drive letter is supposed to be SDB, which is my USB drive. Now we're ready to unmount the USB drive. Type sudo umount /dev/sdb1. Please note that it's not unmount, but umount. And then /dev/sdb1 is the name of the partition. Pay attention to the naming convention here. /dev/sdb refers to the entire physical drive and /dev/sdb1 refers to a partition on that drive. When we're referring to the individual partitions on the same physical drive, we are using a numbering system, such as one, two, and three as we could have more than one partition on a physical drive. In this case, we are dealing with one partition, which is why we have number one next to the drive name stb. Now press enter, and as soon as you do that, you can see that the USB drive icon color is changing. It's grayed out and it also says... And it also says not mounted in between the parentheses. What this means is that now the drive is invisible to the operating system. We just learned how to unmount the partition, and this is very significant in your computer forensics investigation because a lot of times in your investigations, you want your storage device to stay unmounted.

### **Mounting manually**

A storage device connected to your computer is not mounted by default in a forensic copy of your Linux OS. When you're not dealing with an evidence drive and want to mount the drive, here is how you do it. First, identify the drive and the partition you want to mount. From our lesson earlier, we know the partition is /dev/sdb1. To mount it, first of all, we need to create a mount point. A mount point is a directory where you want to see the content of a drive. Let's create a new directory by typing mkdir and then the name of your mount point. And we'll call it usb\_mounted. Press Enter. Type ls to see what's in the current directory. Press Enter. As you can see, now we have a new directory created, called usb\_mounted. Let's see what's inside the newly created directory. Type cd and the name of the mount point, which is ./usb\_mounted/. Press Enter. Type ls and press Enter. There is nothing in the mount point directory we just created. Let's go back to the parent directory. Type cd .. cd here means change directory. The two dots signify the parent directory, so change your directory to the parent directory. We're going back to where we started. Press Enter. Type ls again. We're back to the directory that has another directory called usb\_mounted. Now we're ready to mount our partition. The command is sudo mount file format type option, which is \-t vfat, and then the name of the partition, which is /dev/sdb1 and the name of the mount point. And the directory was ./usb\_mounted/. The dot in front of the forward-slash symbol means the current directory. Now press Enter. Password is kali, K-A-L-I. Press Enter. If you don't get any error messages, the partition has been successfully mounted. Let's see if it works. To check if the partition has been mounted successfully, we have to go to the mount point. Let's do change directory to the mount point. Type cd ./usb\_mounted/. Press Enter. Type ls. Now you see the files and the folders on the partition because the partition has been successfully mounted. As a computer forensics investigator, it's nice to have a way to control when a drive is mounted and unmounted.

### **Challenge: Hashing in Kali**

Let's try to use a hash algorithm to conduct an interesting experiment. We'll create a file first. Type touch test.txt. The touch command creates a new empty file in Linux. Press Enter. Let's see if the file was created. Type ls. It is there. Let me edit it using a Linux editor called Vim. Type vim test.txt. Press Enter. Press I to insert a text. Type, "This is a test\!" Press Escape. Type :wq. So this writes the file and then quits the session. Press Enter. Let's generate a hash value. Type sha256sum test.txt. Press Enter. That's your hash value. Here is your challenge. Find out if modifying the file name also changes its hash value.

### **Solution: Hashing in Kali**

To change the file name, type move, mv space test.txt space challenge.txt, mv space test.txt space challenge.txt, press Enter. Let's see if the file name got changed. Type ls, press Enter. There's no test.txt, but challenge.txt is the new file. Let's generate a hash value. Type sha256sum space challenge.txt Press Enter. Is the hash value the same as the one we just generated earlier? It looks the same and they are the same. Now we know changing the file name doesn't change the hash value.

## Ref

(https://www.linkedin.com/learning/cybersecurity-foundations-computer-forensics/evidence-preservation-approaches?autoSkip=true&resume=false&u=56745521#)